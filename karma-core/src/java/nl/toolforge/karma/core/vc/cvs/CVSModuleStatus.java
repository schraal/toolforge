/*
Karma core - Core of the Karma application
Copyright (C) 2004  Toolforge <www.toolforge.nl>

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
package nl.toolforge.karma.core.vc.cvs;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import org.netbeans.lib.cvsclient.admin.Entry;
import org.netbeans.lib.cvsclient.admin.StandardAdminHandler;
import org.netbeans.lib.cvsclient.command.log.LogInformation;

import nl.toolforge.karma.core.KarmaRuntimeException;
import nl.toolforge.karma.core.Patch;
import nl.toolforge.karma.core.Version;
import nl.toolforge.karma.core.manifest.Module;
import nl.toolforge.karma.core.vc.DevelopmentLine;
import nl.toolforge.karma.core.vc.ModuleStatus;
import nl.toolforge.karma.core.vc.PatchLine;
import nl.toolforge.karma.core.vc.model.MainLine;

/**
 * @author D.A. Smedes
 * @version $Id$
 */
public class CVSModuleStatus implements ModuleStatus {

  private Version nextVersion = null;
  private Version lastVersion = null;
  private Version localVersion = null;
  private boolean existsInRepository = false;

  private List matchingList = null;

  private Module module = null;
  private LogInformation logInfo = null;

  /**
   * Creates a ModuleStatus instance with the LogInformation object that was generated by the <code>cvs log</code>
   * command.
   *
   * @param module The module.
   * @param logInfo A Netbeans LogInformation object.
   */
  public CVSModuleStatus(Module module, LogInformation logInfo) {
    this.module = module;
    this.logInfo = logInfo;

    // Cache some data
    //
    matchingList = collectVersions(module);
  }

  public Version getNextVersion() {

    if (nextVersion == null) {

      if (matchingList.size() == 0) {
        return Version.INITIAL_VERSION;
      }
      nextVersion = (Version) matchingList.get(matchingList.size() - 1);
      nextVersion.setDigit(nextVersion.getLastDigitIndex(), nextVersion.getLastDigit() + 1);
    }
    return nextVersion;
  }

  public Version getLastVersion() {

    if (lastVersion == null) {

      if (matchingList.size() == 0) {
        // todo replace by CVSRuntimeException with ErrorCode instance.
        //
        throw new KarmaRuntimeException(
            "Module " + module.getName() +
            " is invalid in repository " + module.getLocation().getId() +
            "; no version info available.");
      }
      lastVersion = (Version) matchingList.get(matchingList.size() - 1);
      lastVersion.setDigit(lastVersion.getLastDigitIndex(), lastVersion.getLastDigit());
    }

    return lastVersion;
  }

  public Version getLocalVersion() throws CVSException {

    if (localVersion == null) {

      StandardAdminHandler handler = new StandardAdminHandler();

      try {
        Entry[] entries = handler.getEntriesAsArray(module.getBaseDir());

        Entry moduleInfo = null;
        for (int i = 0; i < entries.length; i++) {

          if (entries[i].getName().equals(Module.MODULE_INFO)) {
            moduleInfo = entries[i];
          }
        }
        try {
          if (moduleInfo == null || moduleInfo.getTag() == null || moduleInfo.getTag().matches(DevelopmentLine.DEVELOPMENT_LINE_PATTERN_STRING)) {
            // We have the HEAD of a DevelopmentLine.
            //
            return null;
          }
          localVersion = new Version(moduleInfo.getTag().substring(moduleInfo.getTag().indexOf("_") + 1));
        } catch (Exception e) {
          throw new CVSException(CVSException.LOCAL_MODULE_ERROR, new Object[]{module.getName()});
        }

      } catch (IOException e) {
        throw new CVSException(CVSException.LOCAL_MODULE_ERROR, new Object[]{module.getName()});
      }
    }
    return localVersion;
  }

  public void setExistsInRepository(boolean exists) {
    existsInRepository = exists;
  }

  public boolean existsInRepository() {
    return existsInRepository;
  }

  private List collectVersions(Module module) {

    // Step 1 : get all symbolicnames that apply to the correct pattern
    //
    //
    List matchingList = new ArrayList();

    Collection currentVersions = logInfo.getAllSymbolicNames();

    Pattern pattern = null;

    if (module.hasPatchLine()) {

      // We are working on the PatchLine of a module.
      //
      pattern = Pattern.compile(((PatchLine) module.getPatchLine()).getMatchingPattern());

    } else {
      // We are doing MAINLINE development.
      //
      pattern = Pattern.compile(MainLine.NAME_PREFIX.concat("_").concat(Version.VERSION_PATTERN_STRING));
    }

    // Collect all applicable symbolic names.
    //
    for (Iterator it = currentVersions.iterator(); it.hasNext();) {

      String s = ((LogInformation.SymName) it.next()).getName();

      Matcher matcher = pattern.matcher(s);
      if (matcher.matches()) {

        try {
          if (module.hasPatchLine()) {
            matchingList.add(new Patch(s.substring(s.lastIndexOf("_") + 1)));
          } else {
            matchingList.add(new Version(s.substring(s.lastIndexOf("_") + 1)));
          }
        } catch (PatternSyntaxException p) {
          // Ignore, just no match ...
        }
      }
    }

    // Step 2 : Sort them, so the last one is on top.
    //
    Collections.sort(matchingList);

    return matchingList;
  }
}
